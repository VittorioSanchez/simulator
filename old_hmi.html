<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />

<body>
  <h1>Simple ROS User Interface</h1>
  <p>Connection status: <span id="status"></span></p>
  <p>Last /txt_msg received: <span id="msg"></span></p>
   <span>gamepad status: </span><input id="gp" value=""/><br>
   <span>fw stat: </span><input id="kf" value=""/><br>
   <span>bw stat: </span><input id="kb" value=""/><br>
   <span>r stat: </span><input id="kr" value=""/><br>
   <span>l stat: </span><input id="kl" value=""/><br>
   <span>lin sens: </span><input id="kls" value=""/><br>
   <span>lin sens: </span><input id="kas" value=""/><br>
   <span>lin speed: </span><input id="lin_speed" value="0"/><br>
   <span>ang speed: </span><input id="ang_speed" value="50"/><br>
   <span>longitude: </span><input id="lat" value=""/><br>
   <span>latitude: </span><input id="long" value=""/><br>
   <span>altitude: </span><input id="alt" value=""/><br>
   <span>satellites : </span><input id="sat" value=""/><br>
   <span>zoom : </span><input id="zoom_map" value="18"/><br>
   <span>path : </span><input id="map_path" value=""/><br>
<div style="float: left; width: 200px;" id="gauge2" class="200x160px"></div> 
   <div style="float: left; width: 200px;" id="gauge3" class="200x160px"></div> 
    <div id="map"></div>
    <input onclick="removeLine();" type=button value="Remove line">
    <input onclick="addLine();" type=button value="Add line">

   <button onclick="move(0,0)">stop move</button>
   <span>axes status: </span><input id="axes_gp" value=""/><br>
  <span>video Server Address: </span><input required type="text" id="video_server_link_1" value="192.168.115.140:9090" title="<host>:<port>, default address is autodetected"/><br>
    <span>image stream: </span><input id="image_stream_link_1"/><br>
      <button id="start" style="background-color: green; color: white" onclick="start_video_1();">Call!</button>
      <button  style="background-color: green; color: white" onclick="document.getElementById('img_1').src=document.getElementById('image_stream_link_1').value">startvideo</button>
      <button  style="background-color: red; color: white" onclick="document.getElementById('img_1').src='' ">stopvideo</button>
  <h1>/image_raw</h1>
  <img id="img_1" src="http://192.168.115.140:8080/stream_viewer?topic=/image_raw">
  </img>
</body>

<script src="js/raphael.min.js"></script>
<script src="js/justgage.js"></script>

<script type="text/javascript" src="http://static.robotwebtools.org/roslibjs/current/roslib.min.js"></script>
<meta name="apple-mobile-web-app-capable" content="yes" />
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.7.3/nipplejs.js"></script>
<script type="text/javascript" src="http://maps.googleapis.com/maps/api/js?sensor=false"></script>
<script type="text/javascript" type="text/javascript">




  //////// basic ros web https://msadowski.github.io/ros-web-tutorial-pt1////////////////
  var ros = new ROSLIB.Ros({
    url : 'ws://0.0.0.0:9090'
  });

  ros.on('connection', function() {
    document.getElementById("status").innerHTML = "Connected";
  });

  ros.on('error', function(error) {
    document.getElementById("status").innerHTML = "Error";
  });

  ros.on('close', function() {
    document.getElementById("status").innerHTML = "Closed";
  });
  
  var GPS_listener = new ROSLIB.Topic({
    ros : ros,
    name : '/android/fix', //'/ros_GPS',
    messageType : 'sensor_msgs/NavSatFix'
  });

  GPS_listener.subscribe(function(gps) {
    document.getElementById("lat").value = gps.latitude;
    document.getElementById("long").value = gps.longitude;
    document.getElementById("alt").value = gps.altitude;
    document.getElementById("sat").value = gps.status.service;
    add_GPS_track();
  });




//////////publishing cmdvel topic////////////////
  cmd_vel_listener = new ROSLIB.Topic({
    ros : ros,
    name : "/cmd_vel",
    messageType : 'geometry_msgs/Twist'
  });

  
  move = function (linear, angular) {

    /*if (linear<0){
      linear=-linear;
      sens = 0;
    }
    else {
      sens = 1;
    }*/
    document.getElementById("gp").value = sens;
    var twist = new ROSLIB.Message({
      linear: {
        x: linear,
        y: 0,
        z: 0
      },
      angular: {
        x: 0,
        y: 0,
        z: angular
      }
    });
    cmd_vel_listener.publish(twist);
  }
  var sens = 0;
  var linear_speed=0;
  var angular_speed=50;

  var linear_key=0;
  var angular_key=0;

 

///virtual joystick 
/*
    createJoystick = function () {
      var options = {
        zone: document.getElementById('zone_joystick'),
        threshold: 0.1,
        position: { left: 50 + '%' },
        mode: 'static',
        size: 150,
        color: '#000000',
      };
      manager = nipplejs.create(options);

      //linear_speed = 0;
      //angular_speed = 0;

      self.manager.on('start', function (event, nipple) {
        console.log("Movement start");
      });

      self.manager.on('move', function (event, nipple) {
        console.log("Moving");
      });

      self.manager.on('end', function () {
        console.log("Movement end");
      });
    ///start 
    manager.on('start', function (event, nipple) {
   timer = setInterval(function () {
    move(linear_speed, angular_speed);
  }, 25);
});

    //end
    manager.on('end', function () {
  linear_speed = 0;
  angular_speed = 0;
   //move(0, 0);
});

    //move
    manager.on('move', function (event, nipple) {
  max_linear = 3.0; // m/s
  max_angular = 3.0; // rad/s
  max_distance = 250.0; // pixels;
  linear_speed = Math.sin(nipple.angle.radian) * max_linear * nipple.distance/max_distance;
  document.getElementById("axes_gp").value = window.linear_speed;
  angular_speed = Math.cos(nipple.angle.radian) * max_angular * nipple.distance/max_distance;
  //self.move(linear_speed,angular_speed);
  move(linear_speed, angular_speed)
});


    }*/
var  linear_key_fw = 0;
var  linear_key_bw = 0;
var  angular_key_right = 0;
var  angular_key_left = 0;
var  linear_sens = 1;
var  angular_sens = 5;
var  max_linear_sens = 10;
var  max_angular_sens = 12;

document.addEventListener('keydown', (event) => {
  const nomTouche = event.key;
//alert(`Touche press√©e ${nomTouche}`);
  if (nomTouche === 'z') {
    document.getElementById("kf").value = 1;
    linear_key_bw=1;
    if (linear_speed<0){
        linear_speed = 0;
    }
    if (linear_speed<=50){
      linear_speed = linear_speed + linear_sens;
    }
    return;
  }
  if (nomTouche === 's') {
   document.getElementById("kb").value = 1;
    linear_key_fw=1;
    if (linear_speed>0){
        linear_speed = 0;
    }
    if (linear_speed>=-50){
      linear_speed = linear_speed - linear_sens;
    }
    return;
  }
  if (nomTouche === 'd') {
   document.getElementById("kr").value = 1;
    angular_key_right=1;
    if (angular_speed<100){
      angular_speed += 25;
    }
    return;
  }
  if (nomTouche === 'q') {
   document.getElementById("kl").value = 1;
    angular_key_left=1;
    if (angular_speed>0){
      angular_speed -= 25;
    }
    
    return;
  }
  if (nomTouche === 'r') {
    if (event.altKey) {
      if (linear_sens>0){
        linear_sens--;
      }
    }
    else {
      if (linear_sens<max_linear_sens){
        linear_sens++;
      }
    }
    document.getElementById("kls").value = linear_sens;
    return;
  }
  if (nomTouche === 't') {
    if (event.altKey) {
      if (angular_sens>0){
        angular_sens--;
      }
    }
    else {
      if (angular_sens<max_angular_sens){
        angular_sens++;
      }
    }
   document.getElementById("kas").value = angular_sens;
    return;
  }
},false);


document.addEventListener('keyup', (event) => {
  const nomTouche = event.key;
  if (nomTouche === 'z') {
    document.getElementById("kf").value = 0;
    linear_key_fw=0;
    return;
  }
  if (nomTouche === 's') {
   document.getElementById("kb").value = 0;
    linear_key_bw=0;;
    return;
  }
  if (nomTouche === 'd') {
   document.getElementById("kr").value = 0;
    angular_key_right=0;
    return;
  }
  if (nomTouche === 'q') {
   document.getElementById("kl").value = 0;
    angular_key_left=0;
    return;
  }

},false);

  function Lin_speed(){
    if (linear_key_fw == 0){
      if (linear_speed<linear_sens){
        linear_speed = 0;
      }
      else {
        linear_speed = linear_speed - linear_sens;
      }
    }
    /*if (linear_key_fw == 1){
      if (linear_speed<0){
        linear_speed = 0;
      }
      linear_speed = linear_speed + linear_sens;
    }*/
    if (linear_key_bw == 0){
      if (linear_speed>(-linear_sens)){
        linear_speed = 0;
      }
      else {
        linear_speed = linear_speed + linear_sens;
      }
    } 
    /*if (linear_key_bw == 1){
      if (linear_speed>0){
        linear_speed = 0;
      }
      linear_speed = linear_speed - linear_sens;
    }*/
    /*if (document.getElementById("kf").value == 0){
      if (linear_speed<linear_sens){
        linear_speed = 0;
      }
      else {
        linear_speed = linear_speed - linear_sens;
      }
    }
    if (document.getElementById("kb").value == 1){
      if (linear_speed<0){
        linear_speed = 0;
      }
      linear_speed = linear_speed + linear_sens;
    }
    if (document.getElementById("kb").value == 0){
      if (linear_speed>(-linear_sens)){
        linear_speed = 0;
      }
      else {
        linear_speed = linear_speed + linear_sens;
      }
    } 
    if (document.getElementById("kf").value == 1){
      if (linear_speed>0){
        linear_speed = 0;
      }
      linear_speed = linear_speed - linear_sens;
    }*/
    if (linear_speed>254) {linear_speed=254}
    if (linear_speed<(-254)) {linear_speed=-254}
    document.getElementById("lin_speed").value = linear_speed;
    document.getElementById("gauge3").value = linear_speed;
    document.getElementById("ang_speed").value = angular_speed;
    document.getElementById("gauge2").value = angular_speed;
    move(linear_speed,angular_speed);

  }

  //function Ang_speed(){
    /*if (angular_key_fw == 0){
      if (linear_speed<linear_sens){
        linear_speed = 0;
      }
      else {
        linear_speed = linear_speed - 2*linear_sens;
      }
    }
    if (linear_key_bw == 0){
      if (linear_speed>(-linear_sens)){
        linear_speed = 0;
      }
      else {
        linear_speed = linear_speed + 2*linear_sens;
      }
    } 
    if (linear_speed>254) {linear_speed=254}
    if (linear_speed<(-254)) {linear_speed=-254}
    document.getElementById("lin_speed").value = linear_speed;*/
  //}
    /*if ((angular>0)&(angular<5)) {angular=0}
    if ((angular<0)&(angular>-5)) {angular=0}*/
    window.onload = function () {
      //createJoystick();
      //var stopKey = window.setInterval(move, 10,linear_speed,angular_speed);
      //var stopMove = window.setInterval(move, 10,linear_speed,angular_speed);
      var stopLinSpeed = window.setInterval(Lin_speed, 100);
      //var stopAngSpeed = window.setInterval(Ang_speed, 100);

    }





  ///////////video//////////////////
  function start_video_1(){
    var video_server_link_1 = "http://"+document.getElementById("video_server_link_1").value +"/stream?topic=/image_raw";
    document.getElementById("image_stream_link_1").value = video_server_link_1;
  };
  ///////////end video////////////////

  ///////////gamepad(xbox) source:https://developer.mozilla.org/fr/docs/Web/Guide/API/Gamepad////////////
/*
var haveEvents = 'GamepadEvent' in window;
var controllers = {};
var rAF = window.mozRequestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.requestAnimationFrame;
linear_speed = 0;
      angular_speed = 0;
function connecthandler(e) {
  addgamepad(e.gamepad);
  document.getElementById("gp").value = "gp connect√©";

    timer = setInterval(function () {
    move(linear_speed, angular_speed);
  }, 25);
    linear_speed = 0;
      angular_speed = 0;

}
function addgamepad(gamepad) {
  controllers[gamepad.index] = gamepad; var d = document.createElement("div");
  d.setAttribute("id", "controller" + gamepad.index);
  var t = document.createElement("h1");
  t.appendChild(document.createTextNode("gamepad: " + gamepad.id));
  d.appendChild(t);/*
  var b = document.createElement("div");
  b.className = "buttons";
  for (var i=0; i<gamepad.buttons.length; i++) {
    var e = document.createElement("span");
    e.className = "button";
    e.id = "b" + i;
    e.innerHTML = i;
    b.appendChild(e);
  }
  d.appendChild(b);
  var a = document.createElement("div");
  a.className = "axes";
  for (var i=0; i<gamepad.axes.length; i++) {
    var e = document.createElement("progress");
    e.className = "axis";
    e.id = "a" + i;
    e.setAttribute("max", "2");
    e.setAttribute("value", "1");
    e.innerHTML = i;
    a.appendChild(e);
  }
  /*d.appendChild(a);
  document.getElementById("start").style.display = "none";
  document.body.appendChild(d);*//*
  rAF(updateStatus);
}

function disconnecthandler(e) {
  removegamepad(e.gamepad);
  document.getElementById("gp").value = "gp d√©connect√©";

}

function removegamepad(gamepad) {
  var d = document.getElementById("controller" + gamepad.index);
  document.body.removeChild(d);
  delete controllers[gamepad.index];
}

function updateStatus() {
  if (!haveEvents) {
    scangamepads();
  }
  for (j in controllers) {
    var controller = controllers[j];
    var d = document.getElementById("controller" + j);
    //var buttons = d.getElementsByClassName("button");
    /*for (var i=0; i<controller.buttons.length; i++) {
      var b = buttons[i];
      var val = controller.buttons[i];
      var pressed = val == 1.0;
      if (typeof(val) == "object") {
        pressed = val.pressed;
        val = val.value;
      }
      var pct = Math.round(val * 100) + "%"
      b.style.backgroundSize = pct + " " + pct;
      if (pressed) {
        b.className = "button pressed";
      } else {
        b.className = "button";
      }
    }*/
/*
    //var axes = d.getElementsByClassName("axis");
    linear_speed = controller.axes[1];
    angular_speed = controller.axes[0];
    document.getElementById("axes_gp").value = 0 + ": " + controller.axes[0].toFixed(4);
    /*for (var i=0; i<controller.axes.length; i++) {
      var a = axes[i];
      a.innerHTML = i + ": " + controller.axes[i].toFixed(4);
      
      a.setAttribute("value", controller.axes[i] + 1);
    }*//*
  }
  rAF(updateStatus);
}

function scangamepads() {
  var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
  for (var i = 0; i < gamepads.length; i++) {
    if (gamepads[i]) {
      if (!(gamepads[i].index in controllers)) {
        addgamepad(gamepads[i]);
      } else {
        controllers[gamepads[i].index] = gamepads[i];
      }
    }
  }
}

window.addEventListener("gamepadconnected", connecthandler);
window.addEventListener("gamepaddisconnected", disconnecthandler);
if (!haveEvents) {
  setInterval(scangamepads, 500);
}
*/

  ///////////end gamepad(xbox)////////

  ///////////gauge////////////////

    var gauge3 = new JustGage({

    id: "gauge3",
    value: 0,
    min: -50,
    max: 50,
    label: "speed",
    customSectors: {
    //percents: true, // lo and hi values are in %
    ranges: [{
    color : "#468ceb",
    lo : -50,
    hi : -25
    },
    {
    color : "#46ebeb",
    lo : -25,
    hi : 0
  },
      {color : "#49eb46",
    lo : 1,
    hi : 25
    },
      {color : "#e5421a",
    lo : 25,
    hi : 50
    },
    ]
  }
  });

    var gauge2 = new JustGage({

    id: "gauge2",
    value: 50,
    min: 0,
    max: 100,
    label: "ang",
    /*customSectors: {
    //percents: true, // lo and hi values are in %
    ranges: [{
    color : "#468ceb",
    lo : 0,
    hi : 25
    },
    {
    color : "#46ebeb",
    lo : 26,
    hi : 50
  },
      {color : "#49eb46",
    lo : 51,
    hi : 75
    },
      {color : "#e5421a",
    lo : 76,
    hi : 100
    },
    ]
  }*/
  });

     setInterval(() => {
        gauge3.refresh(document.getElementById("lin_speed").value);
      }, 100)
     setInterval(() => {
        gauge2.refresh(document.getElementById("ang_speed").value);
      }, 100)
  ////////end gauge///////////////
/////////////map
            var element = document.getElementById("map");
            document.getElementById("map").style.width="500px";
            document.getElementById("map").style.height="400px"
            /*
            Build list of map types.
            You can also use var mapTypeIds = ["roadmap", "satellite", "hybrid", "terrain", "OSM"]
            but static lists sucks when google updates the default list of map types.
            */
            // This example creates an interactive map which constructs a polyline based on
      // user clicks. Note that the polyline only appears once its path property
      // contains two LatLng coordinates.

            /*var poly;
            var map;

            var mapTypeIds = [];
            for(var type in google.maps.MapTypeId) {
                mapTypeIds.push(google.maps.MapTypeId[type]);
            }
            mapTypeIds.push("OSM");

            var center_gps = new google.maps.LatLng(document.getElementById("lat").value, document.getElementById("long").value);

            var map = new google.maps.Map(element, {
                center: center_gps,//43.57,1.46),
                zoom: 18,//document.getElementById("zoom_map").value,
                mapTypeId: "satellite",
                mapTypeControlOptions: {
                    mapTypeIds: mapTypeIds
                }
            });

            var marker = new google.maps.Marker({position: center_gps, map: map}) ;


            map.mapTypes.set("OSM", new google.maps.ImageMapType({
                getTileUrl: function(coord, zoom) {
                    // See above example if you need smooth wrapping at 180th meridian
                    return "http://tile.openstreetmap.org/" + zoom + "/" + coord.x + "/" + coord.y + ".png";
                },
                tileSize: new google.maps.Size(256, 256),
                name: "OpenStreetMap",
                maxZoom: 18
            }));*/

            // This example creates an interactive map which constructs a polyline based on
      // user clicks. Note that the polyline only appears once its path property
      // contains two LatLng coordinates.

      var poly;
      var rover;
      var map;
      var center_gps = new google.maps.LatLng(43.571105, 1.466366);
      initMap();

      function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
          zoom: 18,
          center: center_gps,
          mapTypeId: "satellite"
        });

        poly = new google.maps.Polyline({
          strokeColor: '#F00000',
          strokeOpacity: 1.0,
          strokeWeight: 3
        });
        poly.setMap(map);

        rover = new google.maps.Polyline({
          strokeColor: '#00FF33',
          strokeOpacity: 1.0,
          strokeWeight: 3
        });
        rover.setMap(map);


        // Add a listener for the click event
        map.addListener('click', addLatLng);
      }

      // Handles click events on a map, and adds a new point to the Polyline.
      function addLatLng(event) {
        var path = poly.getPath();

        // Because path is an MVCArray, we can simply append a new coordinate
        // and it will automatically appear.
        path.push(event.latLng);
        document.getElementById("map_path").value = event.latLng;//.toString();    
      }

        ///trace sur maps le chemin du rover/////////////
      add_GPS_track = function(){
      var rover_Coords = new google.maps.LatLng(document.getElementById("lat").value, document.getElementById("long").value);
        
        
      var rover_path = rover.getPath();

        // Because path is an MVCArray, we can simply append a new coordinate
        // and it will automatically appear.
        rover_path.push(rover_Coords);
        //rover.setMap("map");
        //document.getElementById("map_path").value = event.latLng;//.toString();   
      }

      function addLine() {
        poly.setMap(map);
      }


      function removeLine() {
        poly.setMap(null);
        //poly = [{lat : 0, long : 0}];
      }

      //////////end map///////////////////
</script>
</head>


</html>
